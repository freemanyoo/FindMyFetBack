React를 이용한 프론트엔드, SpringBoot를 이용한 백엔드를 이용해서 웹프로젝트를 하려하는데 개발환경으로는 intelli J IDEA, intelli J Webstrom, MariaDB, docker 를 이용할거야.
개발도구로는 Spring Data JPA(JpaRepository), QueryDSL, axios 비동기통신, Lombok Spring Boot devTools, ModelMapper, Spring Security, MultiPart통신을 이용한 이미지첨부파일 등록  등 을 이용할거야.

-config
#RootConfig.java
package com.busanit501.findmyfet.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

// 작업 순서2
@Configuration
@EnableJpaAuditing
public class RootConfig {

    @Bean
    public ModelMapper getMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
                .setFieldMatchingEnabled(true)
                .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE)
                .setMatchingStrategy(MatchingStrategies.LOOSE);

        return modelMapper;
    }
}
///
#SwaggerConfig.java
package com.busanit501.findmyfet.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 작업 순서4
@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI openAPI() {

        // Security 설정 추가
        SecurityScheme securityScheme = new SecurityScheme()
                .type(SecurityScheme.Type.HTTP)
                .scheme("bearer")
                .bearerFormat("JWT")
                .name("Authorization");

        return new OpenAPI()
                .info(new Info()
                        .title("레스트 API 테스트")
                        .description("Rest 활용해서 댓글도 구현해보기")
                        .version("1.0.0")
                )
                //추가
                .addSecurityItem(new SecurityRequirement().addList("Authorization"))
                .schemaRequirement("Authorization", securityScheme);
    }

}

-entity

#BaseEntity.java
package com.busanit501.findmyfet.domain;


import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@MappedSuperclass
@EntityListeners(value = {AuditingEntityListener.class})
@Getter
public abstract class BaseEntity {

    @CreatedDate // postRepository.save()가 호출되어 새로운 데이터가 DB에 처음 저장되는 시점에 Spring Data JPA가 현재 시간을 자동으로
    @Column(name = "reg_date", updatable = false)
    private LocalDateTime createdAt; //변수명 변경_240824

    @LastModifiedDate
    @Column(name = "mod_date")
    private LocalDateTime updatedAt; //변수명 변경_240824
}

///


#Post.java
package com.busanit501.findmyfet.domain.post;

import com.busanit501.findmyfet.domain.BaseEntity;
import com.busanit501.findmyfet.domain.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Builder
@AllArgsConstructor // Builder 패턴 쓰기위해서 모든 필드에 생성자 추가
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(exclude = {"images", "user"}) // images 필드는 ToString에서 제외
public class Post extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "post_id")
    private Long id;

    // ERD를 참고하여 나머지 필드를 모두 추가합니다.
    @Column(nullable = false)
    private String title;

    @Lob // 대용량 텍스트를 위한 @Lob 어노테이션
    private String content;

    private String animalName;
    private int animalAge;
    private String animalCategory; // 예시: "개", "고양이" 등
    private String animalBreed; // 품종

    private LocalDateTime lostTime; // 실종 시간

    private double latitude;  // 위도
    private double longitude; // 경도

    private String location; // <<<<<<<<<<<< 잃어버린 장소 추가 250825

    @Enumerated(EnumType.STRING) // "MISSING", "SHELTER" 같은 문자열로 저장
    @Column(nullable = false)
    private PostType postType;

    @Enumerated(EnumType.STRING) // "ACTIVE", "COMPLETED"
    @Column(nullable = false)
    private Status status;

//    private LocalDateTime createdAt;

    // 1:N, Post(1) : Image(N)
    // Post가 삭제되면 연관된 Image도 함께 삭제되도록 cascade 설정
    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default // 빌더 패턴 사용 시 기본값으로 초기화
    private List<Image> images = new ArrayList<>();

    // 연관관계의 주인 : Post(N쪽)
     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "user_id", nullable = false) // user_id 컬럼으로 조인
     private User user;

    //== 연관관계 편의 메서드 ==//
    public void setUser(User user) {
        this.user = user;
    }

    // 연관관계 편의 메서드
    public void addImage(Image image) {
        images.add(image);
        image.setPost(this);
    }

    // 비즈니스 로직 : 업데이트 (모든 필드를 받도록)
    public void update(String title, String content, String animalName, int animalAge, String animalCategory,
                       String animalBreed, LocalDateTime lostTime, double latitude, double longitude, String location, PostType postType) {
        this.title = title;
        this.content = content;
        this.animalName = animalName;
        this.animalAge = animalAge;
        this.animalCategory = animalCategory;
        this.animalBreed = animalBreed;
        this.lostTime = lostTime;
        this.latitude = latitude;
        this.longitude = longitude;
        this.location = location; // 잃어버린장소 추가 250825
        this.postType = postType;
    }

    //Post 엔티티 스스로 자신의 상태를 바꾸도록 메서드
    // 비즈니스 로직 : 찾기 완료 처리
    public void complete() {
        this.status = Status.COMPLETED;
    }
}

///
#PostType.java
package com.busanit501.findmyfet.domain.post;

public enum PostType {
    MISSING, SHELTER
}

#Status.java
package com.busanit501.findmyfet.domain.post;

public enum Status {
    ACTIVE, COMPLETED
}
///
#Image.java
package com.busanit501.findmyfet.domain.post;

import jakarta.persistence.*;

import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(exclude = {"post", "comment"}) // 순환참조 방지함
public class Image {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "image_id")
    private Long id;

    @Column(name = "image_url", nullable = false)
    private String imageUrl; // 이미지 파일 경로

    // N:1, Image(N) : Post(1)
    // 이미지를 조회할 때 연관된 Post 정보가 항상 필요하진 않으므로 LAZY(지연로딩) 설정
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id") // 외래키 컬럼명 지정
    private Post post;

    // N:1, Image(N) : Comment(1)
    // Comment 엔티티 생성 후 주석 해제 및 import 필요
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "comment_id")
    // private Comment comment;


    //== 연관관계 편의 메서드 ==//
    // Post 정보가 업데이트 될 때, Image 쪽에서도 Post 정보를 동기화
    public void setPost(Post post) {
        this.post = post;
    }

//    // Comment 정보가 업데이트 될 때, Image 쪽에서도 Comment 정보를 동기화
//    public void setComment(Comment comment) {
//        this.comment = comment;
//    }
}

///

-repository
#PostRepository.java
package com.busanit501.findmyfet.repository.post;


import com.busanit501.findmyfet.domain.post.Post;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface PostRepository extends JpaRepository<Post, Long> {

    // User 엔티티의 userid 필드를 기준으로 찾도록 수정
    List<Post> findByUser_UseridOrderByCreatedAtDesc(Long userid);
}

///
#ImageRepository.java
package com.busanit501.findmyfet.repository.post;

import com.busanit501.findmyfet.domain.post.Image;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ImageRepository extends JpaRepository<Image, Long> {

}
///


-service(Impl)
#PostService.java
package com.busanit501.findmyfet.service.post;


import com.busanit501.findmyfet.dto.post.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface PostService {

    // 게시판 전체조회
    List<PostListResponseDto> findAllPosts();

    // 게시글 상세 조회
    PostDetailResponseDto findPostById(Long postId);

    // 게시글 등록 (userId 파라미터 추가)
    Long createPost(PostCreateRequestDto requestDto, List<MultipartFile> images, Long userId);

    // 게시글 수정 (userId 파라미터 추가)
    void updatePost(Long postId, PostUpdateRequestDto requestDto, List<MultipartFile> newImages, Long userId);

    // 게시글 삭제 (userId 파라미터 추가)
    void deletePost(Long postId, Long userId);

    // 게시글 찾기 완료 처리 (userId 파라미터 추가)
    void completePost(Long postId, Long userId);

    // 내가 쓴 글 목록 조회 (메서드 추가)
    List<MyPostResponseDto> findMyPosts(Long userId);

}
///
#PostServiceImpl.java
package com.busanit501.findmyfet.service.post;

import com.busanit501.findmyfet.domain.Role;
import com.busanit501.findmyfet.domain.User;
import com.busanit501.findmyfet.domain.post.Image;
import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.post.*;
import com.busanit501.findmyfet.repository.post.ImageRepository;
import com.busanit501.findmyfet.repository.post.PostRepository;
import com.busanit501.findmyfet.repository.user.UserRepository;
import org.springframework.security.access.AccessDeniedException;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor // 생성자 자동주입
@Log4j2
public class PostServiceImpl implements PostService {

    private final PostRepository postRepository;
    private final ImageRepository imageRepository;
    private final FileUploadService fileUploadService;
    private final UserRepository  userRepository;

    // 전체 게시글리스트 조회기능
    @Override
    @Transactional(readOnly = true) // 조회 기능이므로 readOnly=true로 성능 최적화
    public List<PostListResponseDto> findAllPosts() {
        return postRepository.findAll().stream() // DB에서 모든 Post를 가져와서
                .map(PostListResponseDto::new)      // DTO로 변환하고
                .collect(Collectors.toList());      // List로 만든다.
    }

    // 게시글 등록기능
    @Override
    @Transactional
    public Long createPost(PostCreateRequestDto requestDto, List<MultipartFile> images, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("해당 사용자를 찾을 수 없습니다. id=" + userId));

        // 1-1. DTO를 Post 엔티티로 변환 후 저장
        Post post = requestDto.toEntity();
        post.setUser(user); //

        Post savedPost = postRepository.save(post);
        log.info("Saved Post: {}, Author: {}", savedPost.getId(), user.getName());

        if (images != null && !images.isEmpty()) {
            for (MultipartFile imageFile : images) {
                // 2-1. 실제 파일 업로드 로직 호출
                String storedFilename = fileUploadService.upload(imageFile);
                log.info("Uploaded Image: {}", storedFilename);

                if (storedFilename != null) {
                    // 2-2. Image 엔티티 생성
                    Image image = Image.builder()
                            .imageUrl(storedFilename)
                            .build();

                    // 2-3. 연관관계 설정 (Post -> Image)
                    savedPost.addImage(image);

                    // 2-4. Image 엔티티 저장 (Post에 Cascade 설정이 되어 있지만, 명시적으로 저장하는 것이 안전할 수 있음)
                    // CascadeType.ALL 이므로 Post 저장 시 Image도 함께 저장됩니다.

                }
            }
        }
        return savedPost.getId();
    }

    // 상세조회기능
    @Override
    @Transactional(readOnly = true)
    public PostDetailResponseDto findPostById(Long postId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));
        return new PostDetailResponseDto(post);
    }

    @Override
    @Transactional(readOnly = true)
    public List<MyPostResponseDto> findMyPosts(Long userId) {
        return postRepository.findByUser_UseridOrderByCreatedAtDesc(userId)
                .stream()
                .map(MyPostResponseDto::new)
                .collect(Collectors.toList());
    }

    // 삭제기능
    @Override
    @Transactional
    public void deletePost(Long postId,  Long userId) {
        // 1. 게시글 ID로 Post 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        // 2. 연관된 이미지 파일들을 서버에서 삭제
        if (post.getImages() != null && !post.getImages().isEmpty()) {
            for (Image image : post.getImages()) {
                String storedFilename = image.getImageUrl();
                log.info("Deleting Image File: {}", storedFilename);
                fileUploadService.delete(storedFilename);
            }
        }

        // 3. Post 엔티티 삭제
        // Post 엔티티에 cascade = CascadeType.ALL, orphanRemoval = true 설정이 되어 있으므로,
        // Post를 삭제하면 연관된 Image 엔티티들도 DB에서 함께 삭제됩니다.
        postRepository.delete(post);
        log.info("Deleted Post ID: {}", postId);
    }

    // 게시글 수정기능
    @Override
    @Transactional
    public void updatePost(Long postId, PostUpdateRequestDto requestDto, List<MultipartFile> newImages, Long userId) {
        // 1. 게시글 ID로 Post 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        // 2. 기존 이미지 파일 삭제 (간단한 버전: 모든 기존 이미지를 삭제하고 새로 추가)
        if (requestDto.getDeletedImageIds() != null && !requestDto.getDeletedImageIds().isEmpty()) {
            // DB에서 조회한 기존 이미지들의 ID를 Set으로 만들어 빠른 조회를 가능하게 함
            Set<Long> deleteIds = new HashSet<>(requestDto.getDeletedImageIds());

            // Iterator를 사용하여 컬렉션을 순회하면서 안전하게 원소를 제거
            Iterator<Image> iterator = post.getImages().iterator();
            while (iterator.hasNext()) {
                Image image = iterator.next();
                if (deleteIds.contains(image.getId())) {
                    // 2-1. 실제 파일 시스템에서 이미지 파일 삭제
                    fileUploadService.delete(image.getImageUrl());
                    log.info("Deleted image file: {}", image.getImageUrl());

                    // 2-2. 컬렉션에서 Image 엔티티 제거 (orphanRemoval=true에 의해 DB에서도 삭제됨)
                    iterator.remove();
                }
            }
        }
//        post.getImages().clear()가 호출되면, @OneToMany에 설정된 orphanRemoval = true 옵션 덕분에 부모(Post)와의 관계가 끊어진 Image 엔티티들(고아 객체)이 DB에서도 자동으로 삭제


        // 3. 텍스트 정보 업데이트(JPA 더티 체킹 활용)
            // -> 트랜잭션이 끝날 때 변경된 내용을 감지하여 자동으로 UPDATE 쿼리를 실행
        post.update(
                requestDto.getTitle(),
                requestDto.getContent(),
                requestDto.getAnimalName(),
                requestDto.getAnimalAge(),
                requestDto.getAnimalCategory(),
                requestDto.getAnimalBreed(),
                requestDto.getLostTime(),
                requestDto.getLatitude(),
                requestDto.getLongitude(),
                requestDto.getLocation(),
                requestDto.getPostType()
        );

//        더티 체킹 (Dirty Checking):
//        @Transactional 환경에서 postRepository.findById()로 조회된 post 엔티티는 JPA의 영속성 컨텍스트에 의해 관리됩니다.
//        이 상태에서 post.update(...)와 같이 객체의 상태(필드 값)를 변경하면, 트랜잭션이 끝나는 시점에 JPA가 "어? 처음 조회했을 때랑 지금이랑 상태가 다르네?"라고 감지합니다.
//        이 '더러워진(dirty)' 객체를 발견하면, JPA가 자동으로 UPDATE 쿼리를 생성하여 데이터베이스에 반영해줍니다.
//        따라서 postRepository.save(post)를 다시 호출할 필요가 없어 코드가 간결해집니다.


        // 4. 새로운 이미지 파일 추가
        if (newImages != null && !newImages.isEmpty()) {
            for (MultipartFile imageFile : newImages) {
                String storedFilename = fileUploadService.upload(imageFile);
                if (storedFilename != null) {
                    Image image = Image.builder().imageUrl(storedFilename).build();
                    post.addImage(image);
                    log.info("Added new image: {}", storedFilename);
                }
            }
        }
        // postRepository.save(post)를 호출할 필요가 없습니다.
        // 트랜잭션 커밋 ->  더티 체킹 -> post가 자동으로 DB에 반영
    }

    // 찾기완료 처리하는기능
    @Override
    @Transactional
    public void completePost(Long postId, Long userId) {
        // 1. 게시글 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        log.info("Completing Post ID: {}", postId);

        // 2. 게시글 상태를 'COMPLETED'로 변경
        post.complete();

        // 3. 더티 체킹에 의해 트랜잭션 종료 시 자동으로 UPDATE 쿼리 실행됨
    }

    //== 검증 로직 (관리자 권한 추가) ==//
    private void validatePostAuthorOrAdmin(Post post, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("해당 사용자를 찾을 수 없습니다. id=" + userId));

        // 현재 로그인한 사용자가 게시글 작성자도 아니고, 관리자도 아니면 예외 발생
        if (!post.getUser().getUserid().equals(userId) && user.getRole() != Role.Admin) {
            throw new AccessDeniedException("해당 게시글에 대한 수정/삭제 권한이 없습니다.");
        }
    }
} // <<<<<<< 클래스 닫는 괄호

///
#FileUploadService.java
package com.busanit501.findmyfet.service.post;

import org.springframework.web.multipart.MultipartFile;

// 인터페이스로 분리한 이유?
// 나중에 클라우드 스토리지를 변경하더라도 이 파일의 구현체만 변경하면됨.
public interface FileUploadService {
    /**
     * 파일을 업로드하고 저장된 파일의 URL(또는 경로)을 반환합니다.
     * @param multipartFile 업로드할 파일
     * @return 저장된 파일의 접근 URL 또는 경로
     */
    String upload(MultipartFile multipartFile);

    /**
     * 지정된 URL(또는 경로)의 파일을 삭제합니다.
     * @param fileUrl 삭제할 파일의 URL 또는 경로
     */
    void delete(String fileUrl);
}

///
#FileUploadServiceImpl.java
package com.busanit501.findmyfet.service.post;

import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
@Log4j2
public class FileUploadServiceImpl implements FileUploadService {

    // .properties에서 설정한 파일 저장 경로 주입
    @Value("${file.upload-dir}")
    private String uploadDir;

    @Override
    public String upload(MultipartFile multipartFile) {
        // 파일이 비어있는지 확인
        if (multipartFile.isEmpty()) {
            return null;
        }

        // 원본 파일 이름 가져오기
        String originalFilename = multipartFile.getOriginalFilename();
        log.info("Original Filename: " + originalFilename);

        // UUID를 사용하여 고유한 파일 이름 생성 (파일 이름 충돌 방지)
        String uuid = UUID.randomUUID().toString();
        String storeFilename = uuid + "_" + originalFilename;

        // 저장할 전체 경로 생성
        Path savePath = Paths.get(uploadDir + storeFilename);
        log.info("Save Path: " + savePath);

        try {
            // 지정된 경로에 파일 저장
            multipartFile.transferTo(savePath);
        } catch (IOException e) {
            log.error("File upload failed.", e);
            // 예외 처리 (예: 커스텀 예외 발생)
            throw new RuntimeException("파일 업로드에 실패했습니다.", e);
        }

        // 저장된 파일의 이름(경로로 사용될 부분)을 반환
        return storeFilename;
    } // <<<<<<<<<<<< upload 메서드가 여기서 완전히 끝납니다.

    @Override // <<<<<<<<<<<< delete 메서드는 upload 메서드 밖에서 새로 시작됩니다.
    public void delete(String filename) {
        if (filename == null || filename.isEmpty()) {
            return;
        }
        // 전체 파일 경로 생성
        File file = new File(uploadDir + filename);
        log.info("Deleting file: " + file.getAbsolutePath());

        // 파일이 존재하면 삭제
        if (file.exists()) {
            if (file.delete()) {
                log.info("File deleted successfully: " + filename);
            } else {
                log.warn("Failed to delete file: " + filename);
            }
        } else {
            log.warn("File not found, cannot delete: " + filename);
        }
    }
}
///

-dto
#PostCreateRequestDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.domain.post.PostType;
import com.busanit501.findmyfet.domain.post.Status;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
// 게시글 작성 DTO
@Getter
@Setter
public class PostCreateRequestDto {

    private String title;
    private String content;
    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // 잃어버린장소 추가 250825
    private PostType postType;

    // DTO를 Entity로 변환하는 메서드
    public Post toEntity() {
        return Post.builder()
                .title(title)
                .content(content)
                .animalName(animalName)
                .animalAge(animalAge)
                .animalCategory(animalCategory)
                .animalBreed(animalBreed)
                .lostTime(lostTime)

                .latitude(latitude)
                .longitude(longitude)

                .location(location) // <<<<<<<<<<<< 추가 250825

                .postType(postType)
                .status(Status.ACTIVE) // 게시글 작성 시 기본 상태는 ACTIVE
                .build();
    }
}

///
#PostDetailResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.user.AuthorDto;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

// 상세 조회 DTO
@Getter
public class PostDetailResponseDto {

    private Long postId;
    private String title;
    private String content;
    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // 잃어버린장소 추가 250825

    private String postType;
    private String status;
    private LocalDateTime createdAt;
    private AuthorDto author; // TODO: User 기능 연동 후 추가
    private List<String> imageUrls; // 이미지 URL 목록

    public PostDetailResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.content = entity.getContent();
        this.animalName = entity.getAnimalName();
        this.animalAge = entity.getAnimalAge();
        this.animalCategory = entity.getAnimalCategory();
        this.animalBreed = entity.getAnimalBreed();
        this.lostTime = entity.getLostTime();

        this.latitude = entity.getLatitude();
        this.longitude = entity.getLongitude();

        this.location = entity.getLocation(); // 잃어버린장소 추가 250825

        this.postType = entity.getPostType().name();
        this.status = entity.getStatus().name();
        this.createdAt = entity.getCreatedAt();
        this.imageUrls = entity.getImages().stream()
                .map(image -> image.getImageUrl())
                .collect(Collectors.toList());
        if (entity.getUser() != null) { // getMember() -> getUser()
            this.author = new AuthorDto(entity.getUser()); // getMember() -> getUser()
        }
    }
}

///
#PostListResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.user.AuthorDto;
import lombok.Getter;

@Getter
public class PostListResponseDto {
    private Long postId;
    private String title;
    private String animalName;
    private String thumbnailUrl; // 일단은 null 또는 빈 값으로
    private String postType;
    private String status;
//    private LocalDateTime createdAt;

    private AuthorDto author; // AuthorDto 필드 추가

    // 엔티티를 DTO로 변환하는 생성자
    public PostListResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.animalName = entity.getAnimalName();
        this.postType = entity.getPostType().name();
        this.status = entity.getStatus().name();
//        this.createdAt = entity.getCreatedAt();
        if (entity.getUser() != null) {
            this.author = new AuthorDto(entity.getUser()); // getMember() -> getUser()
        }
    }
}

///

#PostUpdateRequestDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.PostType;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Setter
public class PostUpdateRequestDto {
    private String title;
    private String content;
    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // <<<<<<<<<<<< 추가 250825

    private PostType postType;

    // 추가: 수정 시 삭제할 기존 이미지의 ID 목록
    private List<Long> deletedImageIds;
        // 기존 이미지 중 x 버튼을 눌러 삭제한 이미지"들의 ID를 보내주는 방식으로 구현
}


///
#MyPostResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.domain.post.PostType;
import com.busanit501.findmyfet.domain.post.Status;

import java.time.LocalDateTime;

public class MyPostResponseDto {
    private Long postId;
    private String title;
    private PostType postType;
    private Status status;
    private LocalDateTime createdAt;
    // private int commentCount; // TODO: Comment 기능 연동 후 주석 해제

    public MyPostResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.postType = entity.getPostType();
        this.status = entity.getStatus();
        this.createdAt = entity.getCreatedAt();
        // this.commentCount = entity.getComments().size();
    }

}

///

-controller
#PostController.java
package com.busanit501.findmyfet.controller.post;

import com.busanit501.findmyfet.dto.post.*; // DTO 한번에 import
import com.busanit501.findmyfet.service.post.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
// import org.springframework.security.core.annotation.AuthenticationPrincipal; // Spring Security 설정 후 import
// import com.busanit501.findmyfet.security.UserDetailsImpl; // UserDetails 구현체 import
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/posts")
public class PostController {

    private final PostService postService;

    // 2.1 게시글 목록 조회
    @GetMapping
    public ResponseEntity<List<PostListResponseDto>> getPostList() {
        List<PostListResponseDto> posts = postService.findAllPosts();
        return ResponseEntity.ok(posts);
    }

    // 2.2 게시글 상세 조회
    @GetMapping("/{postId}")
    public ResponseEntity<PostDetailResponseDto> getPost(@PathVariable Long postId) {
        PostDetailResponseDto responseDto = postService.findPostById(postId);
        return ResponseEntity.ok(responseDto);
    }

    // 2.3 게시글 작성
    @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity<String> createPost(
            @RequestPart("requestDto") PostCreateRequestDto requestDto,
            @RequestPart(value = "images", required = false) List<MultipartFile> images) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        Long postId = postService.createPost(requestDto, images, tempUserId);
        return ResponseEntity.status(HttpStatus.CREATED).body("게시글이 성공적으로 등록되었습니다. ID: " + postId);
    }

    // 2.4 게시글 수정
    @PutMapping(value = "/{postId}", consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity<String> updatePost(
            @PathVariable Long postId,
            @RequestPart("requestDto") PostUpdateRequestDto requestDto,
            @RequestPart(value = "newImages", required = false) List<MultipartFile> newImages) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.updatePost(postId, requestDto, newImages, tempUserId);
        return ResponseEntity.ok("게시글이 성공적으로 수정되었습니다. ID: " + postId);
    }

    // 2.5 게시글 삭제
    @DeleteMapping("/{postId}")
    public ResponseEntity<String> deletePost(@PathVariable Long postId) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.deletePost(postId, tempUserId);
        return ResponseEntity.ok("게시글이 성공적으로 삭제되었습니다. ID: " + postId);
    }

    // 2.6 찾기 완료 처리
    @PutMapping("/{postId}/complete")
    public ResponseEntity<String> completePost(@PathVariable Long postId) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.completePost(postId, tempUserId);
        return ResponseEntity.ok("찾기 완료 처리되었습니다. ID: " + postId);
    }

    // 2.7 내가 작성한 게시글 목록
    @GetMapping("/my")
    public ResponseEntity<List<MyPostResponseDto>> getMyPosts() {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        List<MyPostResponseDto> myPosts = postService.findMyPosts(tempUserId);
        return ResponseEntity.ok(myPosts);
    }
}
///
-> 이상 Post관련.

-entity(User)
#User.java
package com.busanit501.findmyfet.domain;


import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;

@Entity
@Builder
@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString(exclude = "roleSet")
public class User extends BaseEntity { // 베이스 엔티티 상속
    @Id // primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 키 자동생성
    private Long userid;

    @Column(unique = true, nullable = false)
    private String loginid;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String phone_number;

    @Column(nullable = false , unique = true)
    private String email;

    @Column(nullable = false)
    private String address;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;


}

///
#Role.java
package com.busanit501.findmyfet.domain;

public enum Role {
    User, Admin
}

///

-repository(User)
#UserRepository.java
package com.busanit501.findmyfet.repository.user;

import com.busanit501.findmyfet.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}

///

-dto(User)
#AuthorDto.java
package com.busanit501.findmyfet.dto.user;

import com.busanit501.findmyfet.domain.User;
import lombok.Getter;

@Getter
public class AuthorDto {
    private Long userId;
    private String name;

    public AuthorDto(User user) {
        this.userId = user.getUserid();
        this.name = user.getName();
    }
}

///