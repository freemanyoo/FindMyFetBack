# Spring Boot & React JWT 인증 프로젝트 코드 설명

이 문서는 Spring Security와 JWT를 사용하여 React 프론트엔드와 통신하는 Spring Boot 백엔드 서버의 코드 구조와 각 파일의 역할을 설명합니다.

## 전체적인 인증 흐름

1.  **사용자 로그인 요청**: 클라이언트(React)가 아이디와 비밀번호를 서버의 로그인 경로(`/generateToken`)로 전송합니다.
2.  **인증 및 토큰 발급**: 서버는 전달받은 사용자 정보를 데이터베이스와 비교하여 인증을 수행합니다. 인증에 성공하면, 클라이언트에게 **AccessToken**과 **RefreshToken**을 발급합니다.
3.  **API 요청**: 클라이언트는 발급받은 `AccessToken`을 HTTP 요청 헤더(Authorization Header)에 담아 보호된 API에 데이터를 요청합니다.
4.  **토큰 검증**: 서버는 API 요청을 받을 때마다 헤더에 포함된 `AccessToken`을 검증합니다. 토큰이 유효할 경우에만 요청을 처리하고 데이터를 응답합니다.

---

## 작업 순서별 코드 설명

### 작업 순서 1: `CustomSecurityConfig.java`

이 파일은 Spring Security 설정의 **핵심**입니다. 웹 애플리케이션의 인증/인가와 관련된 모든 규칙을 정의합니다.

*   **어떤 작업인가요?**
    *   애플리케이션의 전반적인 보안 규칙을 설정합니다.
    *   URL별 접근 권한(모두 허용, 특정 권한 필요 등)을 제어합니다.
    *   JWT 토큰 기반의 무상태(Stateless) 인증 방식을 설정합니다.
    *   React 애플리케이션과의 통신을 위한 CORS(Cross-Origin Resource Sharing) 정책을 설정합니다.

*   **주요 설정 및 역할**:
    *   `@Configuration`, `@EnableWebSecurity`: 이 클래스가 Spring의 설정 파일이며, 웹 보안을 활성화함을 명시합니다.
    *   `@EnableMethodSecurity`: 컨트롤러 메서드 수준에서 `@PreAuthorize` 어노테이션을 사용해 권한을 제어할 수 있게 합니다.
    *   `passwordEncoder()`: 비밀번호를 안전하게 암호화하기 위한 `BCryptPasswordEncoder`를 Bean으로 등록합니다.
    *   `securityFilterChain(HttpSecurity http)`: 가장 중요한 부분으로, 다음과 같은 보안 규칙 체인을 설정합니다.
        *   `http.csrf(..).disable()`: REST API 환경에서는 세션 대신 토큰을 사용하므로 CSRF(Cross-Site Request Forgery) 보호 기능을 비활성화합니다.
        *   `sessionManagement(..).sessionCreationPolicy(STATELESS)`: 서버가 세션을 생성하지 않는 **무상태(Stateless)** 방식으로 작동하도록 설정합니다. 이는 JWT 인증의 핵심입니다.
        *   `http.cors(...)`: React 개발 서버(`localhost:3000`)와 Spring Boot 서버(`localhost:8080`) 간의 교차 출처 요청을 허용하기 위한 CORS 정책을 적용합니다.
        *   `APILoginFilter`: 사용자가 `/generateToken` 경로로 로그인을 시도할 때 요청을 가로채 인증을 처리하는 커스텀 필터입니다. (순서 12에서 상세 설명)
        *   `TokenCheckFilter`: `/api/`로 시작하는 모든 요청에 대해 JWT 토큰의 유효성을 검사하는 커스텀 필터입니다.
        *   `RefreshTokenFilter`: `AccessToken`이 만료되었을 때, `/refreshToken` 경로를 통해 새로운 토큰을 발급받기 위한 필터입니다.

---

### 작업 순서 2: `RootConfig.java`

데이터베이스나 비즈니스 로직과 관련된 공통 설정을 정의하는 파일입니다.

*   **어떤 작업인가요?**
    *   애플리케이션 전반에서 사용될 공통 Bean(객체)을 등록합니다.
    *   JPA의 Auditing 기능을 활성화하여 엔티티의 생성/수정 시간을 자동으로 기록합니다.

*   **주요 설정 및 역할**:
    *   `@EnableJpaAuditing`: JPA 엔티티 클래스에서 `@CreatedDate`, `@LastModifiedDate` 같은 어노테이션을 사용할 수 있게 합니다.
    *   `getMapper()`: `ModelMapper` 라이브러리를 Bean으로 등록하여, DTO(Data Transfer Object)와 JPA 엔티티 간의 객체 변환을 쉽게 처리할 수 있도록 돕습니다.

---

### 작업 순서 3: `CustomServletConfig.java`

Spring MVC의 웹 관련 세부 설정을 커스터마이징하는 파일입니다.

*   **어떤 작업인가요?**
    *   정적 리소스(이미지, CSS, JS 파일 등)의 URL 경로와 실제 서버 내 파일 위치를 매핑합니다.

*   **주요 설정 및 역할**:
    *   `addResourceHandlers`: `/files/**`와 같은 특정 URL 패턴으로 요청이 들어오면, `classpath:/static/` 폴더 내에서 해당 파일을 찾아 클라이언트에게 제공하도록 설정합니다.

---

### 작업 순서 4: `SwaggerConfig.java`

API 문서를 자동으로 생성하고 UI를 통해 테스트할 수 있도록 Swagger(OpenAPI)를 설정하는 파일입니다.

*   **어떤 작업인가요?**
    *   개발된 REST API들의 명세서를 자동으로 생성해주는 Swagger UI를 설정합니다.

*   **주요 설정 및 역할**:
    *   `openAPI()`: API 문서의 제목, 설명, 버전 등 기본 정보를 정의합니다.
    *   `SecurityScheme`: Swagger UI 화면에 "Authorize" 버튼을 추가하여 JWT 토큰을 입력하고, 토큰이 필요한 API를 직접 테스트할 수 있는 환경을 제공합니다.

---

### 작업 순서 5: `SampleController.java`

보안 설정이 올바르게 적용되었는지 테스트하기 위한 간단한 REST 컨트롤러입니다.

*   **어떤 작업인가요?**
    *   사용자 권한에 따라 접근이 제어되는 테스트용 API 엔드포인트를 제공합니다.

*   **주요 설정 및 역할**:
    *   `@RestController`: 이 클래스의 모든 메서드는 HTML 뷰가 아닌 JSON과 같은 데이터 자체를 반환하는 REST API임을 나타냅니다.
    *   `@PreAuthorize("hasRole('ROLE_USER')")`: `/api/sample/doA` 경로는 `ROLE_USER` 권한을 가진 사용자만 접근할 수 있도록 제한합니다.
    *   `@PreAuthorize("hasRole('ROLE_ADMIN')")`: `/api/sample/doB` 경로는 `ROLE_ADMIN` 권한을 가진 사용자만 접근할 수 있도록 제한합니다.

---

### 작업 순서 6: `index.html` (API 호출 테스트)

보호된 API를 호출하는 간단한 HTML 테스트 페이지입니다.

*   **어떤 작업인가요?**
    *   JavaScript의 `axios` 라이브러리를 사용하여 Spring Boot 서버의 `/api/sample/doA` API를 호출합니다.

*   **어디에 쓰는 건가요?**
    *   이 페이지를 브라우저에서 실행하면, 인증 토큰 없이 API를 호출하게 됩니다. 이 요청은 `TokenCheckFilter`에 의해 차단되어 401 Unauthorized 또는 403 Forbidden 오류가 발생하며, 이를 통해 보안이 정상적으로 작동함을 확인할 수 있습니다.

---

### 작업 순서 7: `APIUser.java`

데이터베이스의 사용자 테이블과 매핑되는 JPA 엔티티(Entity) 클래스입니다.

*   **어떤 작업인가요?**
    *   데이터베이스에 저장될 사용자의 데이터 구조(테이블 스키마)를 객체 형태로 정의합니다.

*   **주요 설정 및 역할**:
    *   `@Entity`: 이 클래스가 데이터베이스 테이블과 일대일로 매핑되는 객체임을 JPA에게 알려줍니다.
    *   `@Id`: `mid` 필드가 이 테이블의 기본 키(Primary Key)임을 지정합니다.

---

### 작업 순서 8: `APlUserRepository.java`

`APIUser` 엔티티에 대한 데이터베이스 작업을 처리하는 Spring Data JPA 리포지토리(Repository)입니다.

*   **어떤 작업인가요?**
    *   데이터베이스의 `APIUser` 테이블에 대한 CRUD(Create, Read, Update, Delete) 작업을 위한 인터페이스를 정의합니다.

*   **어디에 쓰는 건가요?**
    *   `JpaRepository<APIUser, String>`를 상속받는 것만으로 `findById()`, `save()`, `findAll()` 등 기본적인 데이터베이스操作 메서드가 자동으로 구현됩니다.

---

### 작업 순서 10: `APIUserDetailsService.java`

Spring Security가 사용자 인증 시 실제 사용자 정보를 조회하는 역할을 하는 서비스입니다.

*   **어떤 작업인가요?**
    *   Spring Security의 `UserDetailsService` 인터페이스를 구현하여, 로그인 요청이 오면 사용자 ID를 기반으로 DB에서 사용자 정보를 가져오는 로직을 담당합니다.

*   **주요 설정 및 역할**:
    *   `loadUserByUsername(String username)`: Spring Security가 인증 과정에서 내부적으로 호출하는 메서드입니다.
        1.  파라미터로 받은 `username`으로 DB에서 사용자를 조회합니다.
        2.  사용자 정보가 존재하면, 해당 정보를 Spring Security가 이해할 수 있는 `UserDetails` 객체(`APIUserDTO`)로 변환하여 반환합니다. 이 객체에는 ID, 암호화된 비밀번호, 권한 목록이 포함됩니다.

---

### 작업 순서 11: `APIUserDTO.java`

Spring Security가 내부적으로 사용하는 사용자 정보 객체(`UserDetails`)이자, 계층 간 데이터 전송을 위한 DTO입니다.

*   **어떤 작업인가요?**
    *   보안 인증 과정 및 다른 계층으로 데이터를 전달할 때 사용되는 데이터 전송 객체입니다.

*   **주요 설정 및 역할**:
    *   `extends User`: Spring Security가 제공하는 `User` 클래스를 상속받아 `UserDetails`의 표준 구현체가 됩니다. 이를 통해 Spring Security가 사용자의 인증 정보를 쉽게 관리할 수 있습니다.

---

### 작업 순서 12: `APILoginFilter.java`

사용자 로그인을 처리하기 위해 직접 구현한 커스텀 시큐리티 필터입니다.

*   **어떤 작업인가요?**
    *   `/generateToken` 경로로 들어오는 로그인 요청을 전문적으로 처리합니다.
    *   HTTP 요청 본문(body)에 담겨 오는 JSON 형식의 로그인 정보(`{ "mid": "...", "mpw": "..." }`)를 파싱합니다.

*   **주요 설정 및 역할**:
    *   `attemptAuthentication()`: 실제 인증 시도가 일어나는 메서드입니다.
        1.  요청에서 JSON 데이터를 읽어 사용자 ID와 비밀번호를 추출합니다.
        2.  추출한 정보로 `UsernamePasswordAuthenticationToken`을 생성합니다.
        3.  이 토큰을 `AuthenticationManager`에게 전달하여 인증을 위임합니다. `AuthenticationManager`는 `APIUserDetailsService`를 통해 DB 정보와 대조하여 인증을 수행합니다.
    *   인증에 성공하면, `CustomSecurityConfig`에 설정된 `APILoginSuccessHandler`가 실행되어 최종적으로 JWT 토큰을 생성하고 클라이언트에게 응답합니다.

---

### 작업 순서 13: `index.html` (토큰 발급 테스트)

로그인 API를 호출하여 JWT 토큰을 발급받는 간단한 HTML 테스트 페이지입니다.

*   **어떤 작업인가요?**
    *   "Generate Token" 버튼 클릭 시, 하드코딩된 사용자 정보(`mid`, `mpw`)를 가지고 `/generateToken` API에 POST 요청을 보냅니다.

*   **어디에 쓰는 건가요?**
    *   로그인 기능 및 토큰 발급 과정이 정상적으로 동작하는지 확인하는 용도입니다.
    *   로그인 성공 시 서버로부터 받은 `accessToken`과 `refreshToken`을 브라우저의 `localStorage`에 저장합니다. 실제 React 앱에서는 이렇게 저장된 토큰을 API 요청 시 헤더에 담아 사용하게 됩니다.


---

### 작업 순서 13-1: `.properties` (토큰 발급 키)

        
     com.busanit5012.jwt.secret=busainit501234567890busainit501234567890busainit501234567890

1. 이 코드가 의미하는 것은 무엇인가요? (의미)
   이 한 줄의 코드는 JWT(JSON Web Token)를 생성하고 검증할 때 사용되는 '비밀 키(Secret Key)'를 정의하는 부분입니다.
   비밀 키 (Secret Key): 말 그대로 서버만 알고 있어야 하는 비밀번호와 같은 문자열입니다. 이 키를 기반으로 JWT에 전자 서명을 하거나, 받은 JWT의 서명이 올바른지 검증합니다.
   보안의 핵심: 이 비밀 키는 JWT 기반 인증 시스템의 보안을 책임지는 가장 중요한 요소입니다. 이 키가 외부에 유출되면, 누구나 유효한 JWT를 만들어낼 수 있게 되어 인증 시스템 전체가 무력화됩니다.
   Key의 구성: 일반적으로 JWT Secret Key는 해커가 추측하기 어렵도록 충분히 길고 복잡한 임의의 문자열로 만듭니다. busainit5012... 와 같이 긴 문자열을 사용한 것은 좋은 보안 관행입니다.
   JWT의 서명은 이 비밀 키를 사용하여 생성되며, 두 가지를 보장합니다.
   무결성 (Integrity): 토큰이 발급된 이후, 내용이 단 한 글자라도 변경되지 않았음을 보장합니다. (위변조 방지)
   인증 (Authentication): 이 토큰이 실제로 우리 서버(비밀 키를 아는 주체)에 의해 발급되었음을 보증합니다.

2. 이 코드는 어디에 쓰이는 건가요? (용도)
   이 Secret Key는 JWT 라이프사이클의 두 가지 핵심적인 단계에서 사용됩니다.
   가. JWT 생성 (Token Generation)
   시나리오: 사용자가 아이디와 비밀번호로 로그인을 성공했을 때.
   동작:
   서버는 사용자의 정보(예: 아이디, 권한 등)를 담은 JWT를 생성합니다.
   생성된 토큰의 마지막 부분인 **서명(Signature)**을 만들 때, .properties 파일에 정의된 이 Secret Key를 사용합니다.
   서명이 완료된 토큰을 클라이언트(React 앱)에게 전달합니다.
   나. JWT 검증 (Token Validation)
   시나리오: 클라이언트가 로그인 후 발급받은 JWT를 HTTP 헤더에 담아 보호된 API(예: /api/sample/doA)를 요청할 때.
   동작:
   서버의 필터(TokenCheckFilter)가 요청 헤더에서 JWT를 추출합니다.
   서버는 자신이 보관하고 있는 동일한 Secret Key를 사용하여 클라이언트가 보낸 JWT의 서명이 유효한지 검증합니다.
   서명이 일치하면, "이 토큰은 우리가 발급한 것이 맞고, 중간에 변조되지 않았다"고 신뢰하고 요청을 처리합니다.
   만약 서명이 일치하지 않거나 토큰이 유효하지 않으면, 접근을 거부합니다(예: 401 Unauthorized 또는 403 Forbidden 오류 응답).

3. Spring Boot 프로젝트에서의 실제 사용 예시
   보통 JWT를 다루는 유틸리티 클래스(예: JWTUtil)에서 이 값을 주입받아 사용합니다. @Value 어노테이션을 통해 .properties 파일의 값을 Java 변수로 가져올 수 있습니다.
   code
   Java
   // 예시: JWTUtil.java
   import io.jsonwebtoken.Jwts;
   import io.jsonwebtoken.SignatureAlgorithm;
   import org.springframework.beans.factory.annotation.Value;
   import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtil {

    // application.properties에 정의된 값을 주입받음
    @Value("${com.busanit5012.jwt.secret}")
    private String secretKeyString;

    private SecretKey secretKey;

    // ... (생성자 또는 @PostConstruct에서 secretKey 초기화) ...

    // JWT 생성 메서드
    public String generateToken(Map<String, Object> claims, int days) {
        // ...
        return Jwts.builder()
                .setClaims(claims)
                // ...
                .signWith(secretKey, SignatureAlgorithm.HS256) // ★ 서명 시 Secret Key 사용
                .compact();
    }

    // JWT 검증 메서드
    public Map<String, Object> validateToken(String token) {
        // ...
        Map<String, Object> claims = Jwts.parserBuilder()
                .setSigningKey(secretKey) // ★ 검증 시 Secret Key 사용
                .build()
                .parseClaimsJws(token)
                .getBody();
        return claims;
    }
}
결론적으로, 이 한 줄의 코드는 JWT 기반 인증 시스템의 신뢰성과 보안을 책임지는 가장 중요한 핵심 설정이라고 할 수 있습니다.