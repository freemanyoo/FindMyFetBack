React를 이용한 프론트엔드, SpringBoot를 이용한 백엔드를 이용해서 웹프로젝트를 하려하는데 개발환경으로는 intelli J IDEA, intelli J Webstrom, MariaDB, docker, Node.js 를 이용할거야.
개발도구로는 Spring Data JPA(JpaRepository), QueryDSL, axios 비동기통신, Lombok Spring Boot devTools, ModelMapper, Spring Security, MultiPart통신을 이용한 이미지첨부파일 등록  등 을 이용할거야.

해당 파일을 공유해줄게.
1. 현재 파일들끼리 유기적으로 결합이 되어있는지.
2. 기능적으로 정상 작동하는지(백엔드만으로 Test를 돌린다는 가정하에 CRUD 및 검색, 필터, 전부 작동하는지와 더불어 기획서상으로 빠진 기능이 있는지 체크)
3. 추가적으로 아쉽다고 느끼는점을 듣고싶은데, 여기서 얘기하는건 다른접근방식(예시 : JPAQueryFactory vs. QuerydslRepositorySupport) 같은건 빼고 얘기해줬으면 좋겠어.


25년08월26일까지 작업한 백엔드

-config

#RootConfig.java
package com.busanit501.findmyfet.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

// 작업 순서2
@Configuration
@EnableJpaAuditing
public class RootConfig {

    @Bean
    public ModelMapper getMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
                .setFieldMatchingEnabled(true)
                .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE)
                .setMatchingStrategy(MatchingStrategies.LOOSE);

        return modelMapper;
    }
}

///===================================================

#SwaggerConfig.java
package com.busanit501.findmyfet.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 작업 순서4
@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI openAPI() {

        // Security 설정 추가
        SecurityScheme securityScheme = new SecurityScheme()
                .type(SecurityScheme.Type.HTTP)
                .scheme("bearer")
                .bearerFormat("JWT")
                .name("Authorization");

        return new OpenAPI()
                .info(new Info()
                        .title("레스트 API 테스트")
                        .description("Rest 활용해서 댓글도 구현해보기")
                        .version("1.0.0")
                )
                //추가
                .addSecurityItem(new SecurityRequirement().addList("Authorization"))
                .schemaRequirement("Authorization", securityScheme);
    }

}

///===================================================

-entity

#BaseEntity.java
package com.busanit501.findmyfet.domain;


import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@MappedSuperclass
@EntityListeners(value = {AuditingEntityListener.class})
@Getter
public abstract class BaseEntity {

    @CreatedDate // postRepository.save()가 호출되어 새로운 데이터가 DB에 처음 저장되는 시점에 Spring Data JPA가 현재 시간을 자동으로
    @Column(name = "reg_date", updatable = false)
    private LocalDateTime createdAt; //변수명 변경_240824

    @LastModifiedDate
    @Column(name = "mod_date")
    private LocalDateTime updatedAt; //변수명 변경_240824
}


///===================================================


#Post.java
package com.busanit501.findmyfet.domain.post;

import com.busanit501.findmyfet.domain.BaseEntity;
import com.busanit501.findmyfet.domain.User;
import com.busanit501.findmyfet.dto.post.PostUpdateRequestDto;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Builder
@AllArgsConstructor // Builder 패턴 쓰기위해서 모든 필드에 생성자 추가
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(exclude = {"images", "user"}) // images 필드는 ToString에서 제외
public class Post extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "post_id")
    private Long id;

    // ERD를 참고하여 나머지 필드를 모두 추가합니다.
    @Column(nullable = false)
    private String title;

    @Lob // 대용량 텍스트를 위한 @Lob 어노테이션
    private String content;

    private String animalName;
    private int animalAge;
    private String animalCategory; // 예시: "개", "고양이" 등
    private String animalBreed; // 품종

    private LocalDateTime lostTime; // 실종 시간

    private double latitude;  // 위도
    private double longitude; // 경도

    private String location; // <<<<<<<<<<<< 잃어버린 장소/발견한장소 추가 250825

    @Enumerated(EnumType.STRING) // "MISSING", "SHELTER" 같은 문자열로 저장
    @Column(nullable = false)
    private PostType postType;

    @Enumerated(EnumType.STRING) // "ACTIVE", "COMPLETED"
    @Column(nullable = false)
    private Status status;

//    private LocalDateTime createdAt;

    // 1:N, Post(1) : Image(N)
    // Post가 삭제되면 연관된 Image도 함께 삭제되도록 cascade 설정
    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default // 빌더 패턴 사용 시 기본값으로 초기화
    private List<Image> images = new ArrayList<>();

    // 연관관계의 주인 : Post(N쪽)
     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "user_id", nullable = false) // user_id 컬럼으로 조인
     private User user;

    //== 연관관계 편의 메서드 ==//
    public void setUser(User user) {
        this.user = user;
    }

    // 연관관계 편의 메서드
    public void addImage(Image image) {
        images.add(image);
        image.setPost(this);
    }

    // 비즈니스 로직 : 업데이트 (모든 필드를 받도록)
//    public void update(String title, String content, String animalName, int animalAge, String animalCategory,
//                       String animalBreed, LocalDateTime lostTime, double latitude, double longitude, String location, PostType postType) {
    public void update(PostUpdateRequestDto dto) {
        this.title = dto.getTitle();
        this.content = dto.getContent();
        this.animalName = dto.getAnimalName();
        this.animalAge = dto.getAnimalAge();
        this.animalCategory = dto.getAnimalCategory();
        this.animalBreed = dto.getAnimalBreed();
        this.lostTime = dto.getLostTime();
        this.latitude = dto.getLatitude();
        this.longitude = dto.getLongitude();
        this.location = dto.getLocation();
        this.postType = dto.getPostType();
    }

    //Post 엔티티 스스로 자신의 상태를 바꾸도록 메서드
    // 비즈니스 로직 : 찾기 완료 처리
    public void complete() {
        this.status = Status.COMPLETED;
    }
}


///===================================================

#PostType.java
package com.busanit501.findmyfet.domain.post;

public enum PostType {
    MISSING, SHELTER
}

///===================================================

#Status.java
package com.busanit501.findmyfet.domain.post;

public enum Status {
    ACTIVE, COMPLETED
}

///===================================================

#Image.java
package com.busanit501.findmyfet.domain.post;

import jakarta.persistence.*;

import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(exclude = {"post", "comment"}) // 순환참조 방지함
public class Image {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "image_id")
    private Long id;

    @Column(name = "image_url", nullable = false)
    private String imageUrl; // 이미지 파일 경로

    // N:1, Image(N) : Post(1)
    // 이미지를 조회할 때 연관된 Post 정보가 항상 필요하진 않으므로 LAZY(지연로딩) 설정
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id") // 외래키 컬럼명 지정
    private Post post;

    // N:1, Image(N) : Comment(1)
    // Comment 엔티티 생성 후 주석 해제 및 import 필요
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "comment_id")
    // private Comment comment;


    //== 연관관계 편의 메서드 ==//
    // Post 정보가 업데이트 될 때, Image 쪽에서도 Post 정보를 동기화
    public void setPost(Post post) {
        this.post = post;
    }

//    // Comment 정보가 업데이트 될 때, Image 쪽에서도 Comment 정보를 동기화
//    public void setComment(Comment comment) {
//        this.comment = comment;
//    }
}


///===================================================

-repository

#PostRepository.java
package com.busanit501.findmyfet.repository.post;


import com.busanit501.findmyfet.domain.post.Post;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface PostRepository extends JpaRepository<Post, Long>, PostRepositoryCustom  {

    // User 엔티티의 userid 필드를 기준으로 찾도록 수정
    List<Post> findByUser_UseridOrderByCreatedAtDesc(Long userid);
}



///

#ImageRepository.java
package com.busanit501.findmyfet.repository.post;

import com.busanit501.findmyfet.domain.post.Image;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ImageRepository extends JpaRepository<Image, Long> {

}


///===================================================

#PostRepositoryCustom.java
package com.busanit501.findmyfet.repository.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.paging.PageRequestDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface PostRepositoryCustom {

    // 페이징처리 동적 검색 쿼리를 처리할 메소드
    Page<Post> search(PageRequestDto pageRequestDTO, Pageable pageable);

}


///===================================================

#PostRepositoryCustomImpl.java
package com.busanit501.findmyfet.repository.post;

import com.busanit501.findmyfet.domain.post.Post;

import com.busanit501.findmyfet.domain.post.QPost;
import com.busanit501.findmyfet.dto.paging.PageRequestDto;
import com.querydsl.core.BooleanBuilder;
import com.querydsl.jpa.impl.JPAQuery;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.util.StringUtils;

import java.util.List;

@RequiredArgsConstructor
public class PostRepositoryCustomImpl implements PostRepositoryCustom{

    private final JPAQueryFactory queryFactory;


    @Override
    public Page<Post> search(PageRequestDto pageRequestDTO, Pageable pageable) {
        QPost post = QPost.post;
        BooleanBuilder booleanBuilder = new BooleanBuilder();

        // 검색 조건 추가
        if (StringUtils.hasText(pageRequestDTO.getType())) {
            booleanBuilder.and(post.postType.stringValue().eq(pageRequestDTO.getType()));
        }
        if (StringUtils.hasText(pageRequestDTO.getCategory())) {
            booleanBuilder.and(post.animalCategory.eq(pageRequestDTO.getCategory()));
        }

        // ===================  핵심 변경 사항  ===================
        // 기존 : booleanBuilder.and(post.user.address.contains(pageRequestDTO.getRegion()));
        // 변경 : Post 엔티티의 location 필드와 정확히 일치하는 것을 검색합니다.
        if (StringUtils.hasText(pageRequestDTO.getRegion())) {
            booleanBuilder.and(post.location.eq(pageRequestDTO.getRegion()));
        }
        // ==============================================================

        if (StringUtils.hasText(pageRequestDTO.getKeyword())) {
            booleanBuilder.and(post.title.contains(pageRequestDTO.getKeyword())
                    .or(post.content.contains(pageRequestDTO.getKeyword())));
        }

        // 쿼리 생성
        // N+1 문제 방지를 위해 fetchJoin() 추가
        JPAQuery<Post> query = queryFactory.selectFrom(post)
                .leftJoin(post.user).fetchJoin() // 작성자 정보를 함께 조회
                .where(booleanBuilder)
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .orderBy(post.createdAt.desc());

        List<Post> content = query.fetch();

        // 전체 카운트 쿼리
        JPAQuery<Long> countQuery = queryFactory.select(post.count())
                .from(post)
                .where(booleanBuilder);

        long total = countQuery.fetchOne();

        return new PageImpl<>(content, pageable, total);
    }
}
//post.user.address.contains(...)를 post.location.eq(...)로 변경하여,
// 사용자가 게시글을 작성할 때 직접 입력한 location 값("서울시", "부산시" 등)과 검색어가
// 정확히 일치하는 게시글만 찾도록 수정했습니다.
// 추가로, 게시글 목록 조회 시 각 게시글마다 작성자 정보를 가져오기 위해
// 발생하는 N+1 쿼리 문제를 예방하고자 .leftJoin(post.user).fetchJoin() 코드를
// 추가하여 성능을 최적화했습니다.

///===================================================

-paging

#PageRequestDto.java
package com.busanit501.findmyfet.dto.paging;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;



@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageRequestDto {

    @Builder.Default
    @Min(value = 1)
    @Positive
    private int page = 1;

    @Builder.Default
    @Min(value = 9) // 최소 사이즈를 9로 설정
    @Max(value = 100)
    @Positive
    private int size = 9; // <<<<< 기본 사이즈를 9로 변경 (3x3 그리드)

    // '찾아줘요' 프로젝트의 검색 조건에 맞게 필드 수정
    private String type;     // MISSING | SHELTER
    private String category; // 동물 카테고리 (예: "개", "고양이")
    private String region;   // 지역
    private String keyword;  // 검색 키워드 (제목, 내용 등)

    // Spring Data JPA의 Pageable 객체를 생성하는 헬퍼 메소드
    public Pageable getPageable(String... props) {
        return PageRequest.of(this.page - 1, this.size, Sort.by(props).descending());
    }
}


///===================================================

#PageResponseDto.java
package com.busanit501.findmyfet.dto.paging;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

import java.util.List;

@Getter
@ToString

public class PageResponseDto<E> {

    private int page;
    private int size;
    private int total;
    private int start;
    private int end;

    private boolean prev;
    private boolean next;

    private List<E> dtoList;

    // 빌더 패턴을 이용한, 생성자 구성,
    @Builder(builderMethodName = "withAll")
    public PageResponseDto(PageRequestDto pageRequestDTO, List<E> dtoList, int total) {
        this.page = pageRequestDTO.getPage();
        this.size = pageRequestDTO.getSize();

        this.total = total;
        this.dtoList = dtoList;

        // 5) 시작 페이지
        // 6) 끝 페이지
        // 7) 이전 페이지 여부
        // 8) 다음 페이지 여부
        this.end = (int) (Math.ceil(this.page / 10.0)) * 10;
        this.start = this.end - 9;
        int last = (int) (Math.ceil((total / (double) size)));
        this.end = end > last ? last : end;
        this.prev = this.start > 1;
        this.next = total > this.end * this.size;
    }
}


///===================================================

-service(Impl)
#PostService.java
package com.busanit501.findmyfet.service.post;


import com.busanit501.findmyfet.dto.paging.PageRequestDto;
import com.busanit501.findmyfet.dto.paging.PageResponseDto;
import com.busanit501.findmyfet.dto.post.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface PostService {

    //페이징처리 추가
    PageResponseDto<PostListResponseDto> findAllPosts(PageRequestDto pageRequestDTO);

    // 게시판 전체조회 -> 페이징 처리 + 전체조회로 바꿈.
//    List<PostListResponseDto> findAllPosts();

    // 게시글 상세 조회
    PostDetailResponseDto findPostById(Long postId);

    // 게시글 등록 (userId 파라미터 추가)
    Long createPost(PostCreateRequestDto requestDto, List<MultipartFile> images, Long userId);

    // 게시글 수정 (userId 파라미터 추가)
    void updatePost(Long postId, PostUpdateRequestDto requestDto, List<MultipartFile> newImages, Long userId);

    // 게시글 삭제 (userId 파라미터 추가)
    void deletePost(Long postId, Long userId);

    // 게시글 찾기 완료 처리 (userId 파라미터 추가)
    void completePost(Long postId, Long userId);

    // 내가 쓴 글 목록 조회 (메서드 추가)
    List<MyPostResponseDto> findMyPosts(Long userId);

}

///===================================================

#PostServiceImpl.java
package com.busanit501.findmyfet.service.post;

import com.busanit501.findmyfet.domain.Role;
import com.busanit501.findmyfet.domain.User;
import com.busanit501.findmyfet.domain.post.Image;
import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.paging.PageRequestDto;
import com.busanit501.findmyfet.dto.paging.PageResponseDto;
import com.busanit501.findmyfet.dto.post.*;
import com.busanit501.findmyfet.repository.post.ImageRepository;
import com.busanit501.findmyfet.repository.post.PostRepository;
import com.busanit501.findmyfet.repository.user.UserRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.AccessDeniedException;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor // 생성자 자동주입
@Log4j2
public class PostServiceImpl implements PostService {

    private final PostRepository postRepository;
    private final ImageRepository imageRepository;
    private final FileUploadService fileUploadService;
    private final UserRepository  userRepository;

    // 페이징처리 + 게시판 조회
    @Override
    @Transactional(readOnly = true)
    public PageResponseDto<PostListResponseDto> findAllPosts(PageRequestDto pageRequestDTO) {
        // 1. Pageable 객체 생성 (정렬 기준은 'createdAt')
        Pageable pageable = pageRequestDTO.getPageable("createdAt");

        // 2. QueryDSL을 사용하여 동적 쿼리 및 페이징 실행
        Page<Post> result = postRepository.search(pageRequestDTO, pageable);

        // 3. Page<Post>를 List<PostListResponseDto>로 변환
        List<PostListResponseDto> dtoList = result.getContent().stream()
                .map(PostListResponseDto::new)
                .collect(Collectors.toList());

        // 4. PageResponseDTO를 생성하여 반환
        return PageResponseDto.<PostListResponseDto>withAll()
                .pageRequestDTO(pageRequestDTO)
                .dtoList(dtoList)
                .total((int)result.getTotalElements())
                .build();
    }

    // 전체 게시글리스트 조회기능
//    @Override
//    @Transactional(readOnly = true) // 조회 기능이므로 readOnly=true로 성능 최적화
//    public List<PostListResponseDto> findAllPosts() {
//        return postRepository.findAll().stream() // DB에서 모든 Post를 가져와서
//                .map(PostListResponseDto::new)      // DTO로 변환하고
//                .collect(Collectors.toList());      // List로 만든다.
//    }

    // 게시글 등록기능
    @Override
    @Transactional
    public Long createPost(PostCreateRequestDto requestDto, List<MultipartFile> images, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("해당 사용자를 찾을 수 없습니다. id=" + userId));

        // 1-1. DTO를 Post 엔티티로 변환 후 저장
        Post post = requestDto.toEntity();
        post.setUser(user); //

        Post savedPost = postRepository.save(post);
        log.info("Saved Post: {}, Author: {}", savedPost.getId(), user.getName());

        if (images != null && !images.isEmpty()) {
            for (MultipartFile imageFile : images) {
                // 2-1. 실제 파일 업로드 로직 호출
                String storedFilename = fileUploadService.upload(imageFile);
                log.info("Uploaded Image: {}", storedFilename);

                if (storedFilename != null) {
                    // 2-2. Image 엔티티 생성
                    Image image = Image.builder()
                            .imageUrl(storedFilename)
                            .build();

                    // 2-3. 연관관계 설정 (Post -> Image)
                    savedPost.addImage(image);

                    // 2-4. Image 엔티티 저장 (Post에 Cascade 설정이 되어 있지만, 명시적으로 저장하는 것이 안전할 수 있음)
                    // CascadeType.ALL 이므로 Post 저장 시 Image도 함께 저장됩니다.

                }
            }
        }
        return savedPost.getId();
    }

    // 상세조회기능
    @Override
    @Transactional(readOnly = true)
    public PostDetailResponseDto findPostById(Long postId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));
        return new PostDetailResponseDto(post);
    }

    @Override
    @Transactional(readOnly = true)
    public List<MyPostResponseDto> findMyPosts(Long userId) {
        return postRepository.findByUser_UseridOrderByCreatedAtDesc(userId)
                .stream()
                .map(MyPostResponseDto::new)
                .collect(Collectors.toList());
    }

    // 삭제기능
    @Override
    @Transactional
    public void deletePost(Long postId,  Long userId) {
        // 1. 게시글 ID로 Post 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        // 2. 연관된 이미지 파일들을 서버에서 삭제
        if (post.getImages() != null && !post.getImages().isEmpty()) {
            for (Image image : post.getImages()) {
                String storedFilename = image.getImageUrl();
                log.info("Deleting Image File: {}", storedFilename);
                fileUploadService.delete(storedFilename);
            }
        }

        // 3. Post 엔티티 삭제
        // Post 엔티티에 cascade = CascadeType.ALL, orphanRemoval = true 설정이 되어 있으므로,
        // Post를 삭제하면 연관된 Image 엔티티들도 DB에서 함께 삭제됩니다.
        postRepository.delete(post);
        log.info("Deleted Post ID: {}", postId);
    }

    // 게시글 수정기능
    @Override
    @Transactional
    public void updatePost(Long postId, PostUpdateRequestDto requestDto, List<MultipartFile> newImages, Long userId) {
        // 1. 게시글 ID로 Post 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        // 2. 기존 이미지 파일 삭제 (간단한 버전: 모든 기존 이미지를 삭제하고 새로 추가)
        if (requestDto.getDeletedImageIds() != null && !requestDto.getDeletedImageIds().isEmpty()) {
            // DB에서 조회한 기존 이미지들의 ID를 Set으로 만들어 빠른 조회를 가능하게 함
            Set<Long> deleteIds = new HashSet<>(requestDto.getDeletedImageIds());

            // Iterator를 사용하여 컬렉션을 순회하면서 안전하게 원소를 제거
            Iterator<Image> iterator = post.getImages().iterator();
            while (iterator.hasNext()) {
                Image image = iterator.next();
                if (deleteIds.contains(image.getId())) {
                    // 2-1. 실제 파일 시스템에서 이미지 파일 삭제
                    fileUploadService.delete(image.getImageUrl());
                    log.info("Deleted image file: {}", image.getImageUrl());

                    // 2-2. 컬렉션에서 Image 엔티티 제거 (orphanRemoval=true에 의해 DB에서도 삭제됨)
                    iterator.remove();
                }
            }
        }
//        post.getImages().clear()가 호출되면, @OneToMany에 설정된 orphanRemoval = true 옵션 덕분에 부모(Post)와의 관계가 끊어진 Image 엔티티들(고아 객체)이 DB에서도 자동으로 삭제


        // 3. 텍스트 정보 업데이트(JPA 더티 체킹 활용)
            // -> 트랜잭션이 끝날 때 변경된 내용을 감지하여 자동으로 UPDATE 쿼리를 실행
        post.update(requestDto);

//        더티 체킹 (Dirty Checking):
//        @Transactional 환경에서 postRepository.findById()로 조회된 post 엔티티는 JPA의 영속성 컨텍스트에 의해 관리됩니다.
//        이 상태에서 post.update(...)와 같이 객체의 상태(필드 값)를 변경하면, 트랜잭션이 끝나는 시점에 JPA가 "어? 처음 조회했을 때랑 지금이랑 상태가 다르네?"라고 감지합니다.
//        이 '더러워진(dirty)' 객체를 발견하면, JPA가 자동으로 UPDATE 쿼리를 생성하여 데이터베이스에 반영해줍니다.
//        따라서 postRepository.save(post)를 다시 호출할 필요가 없어 코드가 간결해집니다.


        // 4. 새로운 이미지 파일 추가
        if (newImages != null && !newImages.isEmpty()) {
            for (MultipartFile imageFile : newImages) {
                String storedFilename = fileUploadService.upload(imageFile);
                if (storedFilename != null) {
                    Image image = Image.builder().imageUrl(storedFilename).build();
                    post.addImage(image);
                    log.info("Added new image: {}", storedFilename);
                }
            }
        }
        // postRepository.save(post)를 호출할 필요가 없습니다.
        // 트랜잭션 커밋 ->  더티 체킹 -> post가 자동으로 DB에 반영
    }

    // 찾기완료 처리하는기능
    @Override
    @Transactional
    public void completePost(Long postId, Long userId) {
        // 1. 게시글 엔티티 조회
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id=" + postId));

        validatePostAuthorOrAdmin(post, userId); // 권한 검사

        log.info("Completing Post ID: {}", postId);

        // 2. 게시글 상태를 'COMPLETED'로 변경
        post.complete();

        // 3. 더티 체킹에 의해 트랜잭션 종료 시 자동으로 UPDATE 쿼리 실행됨
    }

    //== 검증 로직 (관리자 권한 추가) ==//
    private void validatePostAuthorOrAdmin(Post post, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("해당 사용자를 찾을 수 없습니다. id=" + userId));

        // 현재 로그인한 사용자가 게시글 작성자도 아니고, 관리자도 아니면 예외 발생
        if (!post.getUser().getUserid().equals(userId) && user.getRole() != Role.Admin) {
            throw new AccessDeniedException("해당 게시글에 대한 수정/삭제 권한이 없습니다.");
        }
    }
}

///===================================================

#FileUploadService.java
package com.busanit501.findmyfet.service.post;

import org.springframework.web.multipart.MultipartFile;

// 인터페이스로 분리한 이유?
// 나중에 클라우드 스토리지를 변경하더라도 이 파일의 구현체만 변경하면됨.
public interface FileUploadService {
    /**
     * 파일을 업로드하고 저장된 파일의 URL(또는 경로)을 반환합니다.
     * @param multipartFile 업로드할 파일
     * @return 저장된 파일의 접근 URL 또는 경로
     */
    String upload(MultipartFile multipartFile);

    /**
     * 지정된 URL(또는 경로)의 파일을 삭제합니다.
     * @param fileUrl 삭제할 파일의 URL 또는 경로
     */
    void delete(String fileUrl);
}



///===================================================

#FileUploadServiceImpl.java
package com.busanit501.findmyfet.service.post;

import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
@Log4j2
public class FileUploadServiceImpl implements FileUploadService {

    // .properties에서 설정한 파일 저장 경로 주입
    @Value("${file.upload-dir}")
    private String uploadDir;

    @Override
    public String upload(MultipartFile multipartFile) {
        // 파일이 비어있는지 확인
        if (multipartFile.isEmpty()) {
            return null;
        }

        // 원본 파일 이름 가져오기
        String originalFilename = multipartFile.getOriginalFilename();
        log.info("Original Filename: " + originalFilename);

        // UUID를 사용하여 고유한 파일 이름 생성 (파일 이름 충돌 방지)
        String uuid = UUID.randomUUID().toString();
        String storeFilename = uuid + "_" + originalFilename;

        // 저장할 전체 경로 생성
        Path savePath = Paths.get(uploadDir + storeFilename);
        log.info("Save Path: " + savePath);

        try {
            // 지정된 경로에 파일 저장
            multipartFile.transferTo(savePath);
        } catch (IOException e) {
            log.error("File upload failed.", e);
            // 예외 처리 (예: 커스텀 예외 발생)
            throw new RuntimeException("파일 업로드에 실패했습니다.", e);
        }

        // 저장된 파일의 이름(경로로 사용될 부분)을 반환
        return storeFilename;
    } // <<<<<<<<<<<< upload 메서드가 여기서 완전히 끝납니다.

    @Override // <<<<<<<<<<<< delete 메서드는 upload 메서드 밖에서 새로 시작됩니다.
    public void delete(String filename) {
        if (filename == null || filename.isEmpty()) {
            return;
        }
        // 전체 파일 경로 생성
        File file = new File(uploadDir + filename);
        log.info("Deleting file: " + file.getAbsolutePath());

        // 파일이 존재하면 삭제
        if (file.exists()) {
            if (file.delete()) {
                log.info("File deleted successfully: " + filename);
            } else {
                log.warn("Failed to delete file: " + filename);
            }
        } else {
            log.warn("File not found, cannot delete: " + filename);
        }
    }
}

///===================================================

#SearchService.java
package com.busanit501.findmyfet.search_post;

import com.busanit501.findmyfet.search_post.CategoryDto;

import java.util.List;

public interface SearchService {

    /**
     * 프론트엔드 검색 필터에 사용될 동물 카테고리 및 품종 목록을 반환합니다.
     */
    List<CategoryDto> getCategoryList();

    /**
     * 프론트엔드 검색 필터에 사용될 지역 목록을 반환합니다.
     */
    List<String> getRegionList();

}

///===================================================

#SearchServiceImpl.java
package com.busanit501.findmyfet.search_post;

import com.busanit501.findmyfet.search_post.CategoryDto;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SearchServiceImpl implements SearchService {

    @Override
    public List<CategoryDto> getCategoryList() {
        // 기획서 기반 하드코딩
        // 추후 이 데이터를 DB에서 관리하도록 확장할 수 있습니다.
        CategoryDto dogCategory = new CategoryDto("개", List.of("말티즈", "푸들", "골든리트리버", "진돗개"));
        CategoryDto catCategory = new CategoryDto("고양이", List.of("코리안숏헤어", "페르시안", "러시안블루", "샴"));

        return List.of(dogCategory, catCategory);
    }

    @Override
    public List<String> getRegionList() {
        // 기획서 기반 하드코딩
        // Post의 location 필드에 입력될 값들과 일치해야
        return List.of(
                "서울시", "부산시", "대구시", "인천시", "광주시",
                "대전시", "울산시", "경기도", "강원도"
                // 필요에 따라 다른 지역 추가
        );
    }
}

///===================================================

-dto

#PostCreateRequestDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.domain.post.PostType;
import com.busanit501.findmyfet.domain.post.Status;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
// 게시글 작성 DTO
@Getter
@Setter
public class PostCreateRequestDto {

    @NotBlank(message = "제목은 필수 입력 항목입니다.")
    private String title;

    @NotBlank(message = "내용은 필수 입력 항목입니다.")
    private String content;

    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // 잃어버린장소 추가 250825
    private PostType postType;

    // DTO를 Entity로 변환하는 메서드
    public Post toEntity() {
        return Post.builder()
                .title(title)
                .content(content)
                .animalName(animalName)
                .animalAge(animalAge)
                .animalCategory(animalCategory)
                .animalBreed(animalBreed)
                .lostTime(lostTime)

                .latitude(latitude)
                .longitude(longitude)

                .location(location) // <<<<<<<<<<<< 추가 250825

                .postType(postType)
                .status(Status.ACTIVE) // 게시글 작성 시 기본 상태는 ACTIVE
                .build();
    }
}

///===================================================

#PostDetailResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.user.AuthorDto;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

// 상세 조회 DTO
@Getter
public class PostDetailResponseDto {

    private Long postId;
    private String title;
    private String content;
    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // 잃어버린장소 추가 250825

    private String postType;
    private String status;
    private LocalDateTime createdAt;
    private AuthorDto author; // TODO: User 기능 연동 후 추가
    private List<String> imageUrls; // 이미지 URL 목록

    public PostDetailResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.content = entity.getContent();
        this.animalName = entity.getAnimalName();
        this.animalAge = entity.getAnimalAge();
        this.animalCategory = entity.getAnimalCategory();
        this.animalBreed = entity.getAnimalBreed();
        this.lostTime = entity.getLostTime();

        this.latitude = entity.getLatitude();
        this.longitude = entity.getLongitude();

        this.location = entity.getLocation(); // 잃어버린장소 추가 250825

        this.postType = entity.getPostType().name();
        this.status = entity.getStatus().name();
        this.createdAt = entity.getCreatedAt();
        this.imageUrls = entity.getImages().stream()
                .map(image -> image.getImageUrl())
                .collect(Collectors.toList());
        if (entity.getUser() != null) { // getMember() -> getUser()
            this.author = new AuthorDto(entity.getUser()); // getMember() -> getUser()
        }
    }
}


///===================================================

#PostListResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.dto.user.AuthorDto;
import lombok.Getter;

@Getter
public class PostListResponseDto {
    private Long postId;
    private String title;
    private String animalName;
    private String thumbnailUrl; // 디폴트값 null;
    private String postType;
    private String status;

    private AuthorDto author; // AuthorDto 필드 추가

    // 엔티티를 DTO로 변환하는 생성자
    public PostListResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.animalName = entity.getAnimalName();
        this.postType = entity.getPostType().name();
        this.status = entity.getStatus().name();
//        this.createdAt = entity.getCreatedAt();
        if (entity.getUser() != null) {
            this.author = new AuthorDto(entity.getUser());
        }
        // 게시글에 이미지가 존재하면, 첫 번째 이미지의 URL을 thumbnailUrl로 설정합니다.
        // 이미지가 없으면 기존처럼 null로 유지
        if (entity.getImages() != null && !entity.getImages().isEmpty()) {
            this.thumbnailUrl = entity.getImages().get(0).getImageUrl();
        }
    }
}

///===================================================

#PostUpdateRequestDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.PostType;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Setter
public class PostUpdateRequestDto {
    private String title;
    private String content;
    private String animalName;
    private int animalAge;
    private String animalCategory;
    private String animalBreed;
    private LocalDateTime lostTime;

    private double latitude;
    private double longitude;

    private String location; // <<<<<<<<<<<< 추가 250825

    private PostType postType;

    // 추가: 수정 시 삭제할 기존 이미지의 ID 목록
    private List<Long> deletedImageIds;
        // 기존 이미지 중 x 버튼을 눌러 삭제한 이미지"들의 ID를 보내주는 방식으로 구현
}



///===================================================

#MyPostResponseDto.java
package com.busanit501.findmyfet.dto.post;

import com.busanit501.findmyfet.domain.post.Post;
import com.busanit501.findmyfet.domain.post.PostType;
import com.busanit501.findmyfet.domain.post.Status;

import java.time.LocalDateTime;

public class MyPostResponseDto {
    private Long postId;
    private String title;
    private PostType postType;
    private Status status;
    private LocalDateTime createdAt;
    // private int commentCount; // TODO: Comment 기능 연동 후 주석 해제

    public MyPostResponseDto(Post entity) {
        this.postId = entity.getId();
        this.title = entity.getTitle();
        this.postType = entity.getPostType();
        this.status = entity.getStatus();
        this.createdAt = entity.getCreatedAt();
        // this.commentCount = entity.getComments().size();
    }

}

///===================================================

-search
#CategoryDto.java
package com.busanit501.findmyfet.search_post;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.util.List;

//동물 Category(개, 고양이)와 하위 Breed(품종) 목록을 담는역할
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDto {
    private String category;
    private List<String> breeds;

}


///===================================================

-controller
#PostController.java
package com.busanit501.findmyfet.controller.post;

import com.busanit501.findmyfet.dto.paging.PageRequestDto;
import com.busanit501.findmyfet.dto.paging.PageResponseDto;
import com.busanit501.findmyfet.dto.post.*; // DTO 한번에 import
import com.busanit501.findmyfet.service.post.PostService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
// import org.springframework.security.core.annotation.AuthenticationPrincipal; // Spring Security 설정 후 import
// import com.busanit501.findmyfet.security.UserDetailsImpl; // UserDetails 구현체 import
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/posts")
public class PostController {

    private final PostService postService;

    // 1 게시글 목록 조회(페이징처리 + 검색기능)
    @GetMapping
//    public ResponseEntity<List<PostListResponseDto>> getPostList() {
//        List<PostListResponseDto> posts = postService.findAllPosts();
//        return ResponseEntity.ok(posts);
    public ResponseEntity<PageResponseDto<PostListResponseDto>> getPostList(PageRequestDto pageRequestDTO) {
        PageResponseDto<PostListResponseDto> response = postService.findAllPosts(pageRequestDTO);
        return ResponseEntity.ok(response);
    }


    // 2 게시글 상세 조회
    @GetMapping("/{postId}")
    public ResponseEntity<PostDetailResponseDto> getPost(@PathVariable Long postId) {
        PostDetailResponseDto responseDto = postService.findPostById(postId);
        return ResponseEntity.ok(responseDto);
    }

    // 3 게시글 작성
    @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity<String> createPost(
            @Valid @RequestPart("requestDto") PostCreateRequestDto requestDto,
            @RequestPart(value = "images", required = false) List<MultipartFile> images) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        Long postId = postService.createPost(requestDto, images, tempUserId);
        return ResponseEntity.status(HttpStatus.CREATED).body("게시글이 성공적으로 등록되었습니다. ID: " + postId);
    }

    // 4 게시글 수정
    @PutMapping(value = "/{postId}", consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity<String> updatePost(
            @PathVariable Long postId,
            @RequestPart("requestDto") PostUpdateRequestDto requestDto,
            @RequestPart(value = "newImages", required = false) List<MultipartFile> newImages) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.updatePost(postId, requestDto, newImages, tempUserId);
        return ResponseEntity.ok("게시글이 성공적으로 수정되었습니다. ID: " + postId);
    }

    // 5 게시글 삭제
    @DeleteMapping("/{postId}")
    public ResponseEntity<String> deletePost(@PathVariable Long postId) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.deletePost(postId, tempUserId);
        return ResponseEntity.ok("게시글이 성공적으로 삭제되었습니다. ID: " + postId);
    }

    // 6 찾기 완료 처리
    @PutMapping("/{postId}/complete")
    public ResponseEntity<String> completePost(@PathVariable Long postId) {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        postService.completePost(postId, tempUserId);
        return ResponseEntity.ok("찾기 완료 처리되었습니다. ID: " + postId);
    }

    // 7 내가 작성한 게시글 목록
    @GetMapping("/my")
    public ResponseEntity<List<MyPostResponseDto>> getMyPosts() {
        // @AuthenticationPrincipal UserDetailsImpl userDetails) { // TODO: Security 연동 후 주석 해제

        // Long userId = userDetails.getUser().getUserid(); // TODO: Security 연동 후 이 코드로 교체
        Long tempUserId = 1L; // <<<<<<<<<<<<<<<<<<<< 임시 사용자 ID (테스트용)

        List<MyPostResponseDto> myPosts = postService.findMyPosts(tempUserId);
        return ResponseEntity.ok(myPosts);
    }
}

///===================================================
-search
#SearchController.java
package com.busanit501.findmyfet.search_post;

import com.busanit501.findmyfet.search_post.CategoryDto;
import com.busanit501.findmyfet.search_post.SearchService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api")
public class SearchController {

    private final SearchService searchService;


    @GetMapping("/categories")
    public ResponseEntity<List<CategoryDto>> getCategoryList() {
        List<CategoryDto> categories = searchService.getCategoryList();
        return ResponseEntity.ok(categories);
    }


    @GetMapping("/regions")
    public ResponseEntity<List<String>> getRegionList() {
        List<String> regions = searchService.getRegionList();
        return ResponseEntity.ok(regions);
    }

}

///===================================================
-src/main/java/com/busanit501/findmyfet/dto/error/ErrorResponse.java
package com.busanit501.findmyfet.dto.error;

import lombok.Getter;

// 역할: 기획서에 명시된 {"success": false, "error": {"code": "...", "message": "..."}} 와 유사한 구조를 만들기 위한 데이터
@Getter
public class ErrorResponse {
    private final String code;
    private final String message;

    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
    }
}

///===================================================
src/main/java/com/busanit501/findmyfet/exception/GlobalExceptionHandler.java
package com.busanit501.findmyfet.exception;
import com.busanit501.findmyfet.dto.error.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ExceptionHandler;

import org.springframework.web.bind.annotation.RestControllerAdvice;

// 모든 컨트롤러에서 발생하는 예외를 잡아서 처리해주는 클래스
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 특정 예외(IllegalArgumentException)를 잡아서 하나의 메소드에서 공통 처리
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException ex) {
        // 'NOT_FOUND' 코드와 예외 메시지를 담은 ErrorResponse 객체 생성
        ErrorResponse response = new ErrorResponse("BAD_REQUEST", ex.getMessage());
        // 400 (Bad Request) 상태 코드와 함께 ErrorResponse를 클라이언트에게 반환
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    // 권한 관련 예외 처리
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(AccessDeniedException ex) {
        ErrorResponse response = new ErrorResponse("FORBIDDEN", ex.getMessage());
        // 403 (Forbidden) 상태 코드와 함께 응답
        return new ResponseEntity<>(response, HttpStatus.FORBIDDEN);
    }

    // 향후 다른 종류의 예외가 생기면 여기에 메소드를 추가하면 됩니다.
    // @ExceptionHandler(SomeOtherException.class)
    // public ResponseEntity<ErrorResponse> handleSomeOtherException(SomeOtherException ex) { ... }
}


///===================================================

///===================================================


-> 이상 Post관련.

-entity(User)
#User.java
package com.busanit501.findmyfet.domain;


import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;

@Entity
@Builder
@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString(exclude = "roleSet")
public class User extends BaseEntity { // 베이스 엔티티 상속
    @Id // primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 키 자동생성
    private Long userid;

    @Column(unique = true, nullable = false)
    private String loginid;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String phone_number;

    @Column(nullable = false , unique = true)
    private String email;

    @Column(nullable = false)
    private String address;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;


}

///===================================================

#Role.java
package com.busanit501.findmyfet.domain;

public enum Role {
    User, Admin
}

///===================================================

-repository(User)

#UserRepository.java
package com.busanit501.findmyfet.repository.user;

import com.busanit501.findmyfet.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}

///===================================================

-dto(User)
#AuthorDto.java
package com.busanit501.findmyfet.dto.user;

import com.busanit501.findmyfet.domain.User;
import lombok.Getter;

@Getter
public class AuthorDto {
    private Long userId;
    private String name;

    public AuthorDto(User user) {
        this.userId = user.getUserid();
        this.name = user.getName();
    }
}

///