### 2. 마스터 데이터 관리 방식 리팩토링 가이드 (`.md` 파일)
````markdown
# 리팩토링 가이드: 마스터 데이터(카테고리, 지역) 관리

이 문서는 현재 `Post` 엔티티에 `String` 타입으로 저장된 `animalCategory`, `animalBreed`, `location` 필드를 별도의 독립적인 엔티티(마스터 데이터)로 분리하여 관리하는 리팩토링 과정을 안내합니다.

## 왜 이 리팩토링이 필요한가?

-   **데이터 일관성**: "서울시", "서울", "서울특별시"와 같은 중복 및 비일관적인 데이터 입력을 원천적으로 방지합니다.
-   **유지보수 용이성**: "경기도"가 "경기특별자치도"로 변경될 때, 마스터 테이블의 단 하나의 행만 수정하면 모든 관련 데이터가 자동으로 업데이트됩니다.
-   **확장성**: 관리자 페이지 등에서 새로운 지역이나 동물 카테고리를 DB에 추가하는 것만으로 손쉽게 서비스에 반영할 수 있습니다.

---

## 리팩토링 단계별 절차

### Step 1: 새로운 마스터 데이터 엔티티 생성

`domain` 패키지 또는 `domain/master`와 같은 하위 패키지에 새로운 엔티티들을 생성합니다.

**`Region.java`**
```java
package com.busanit501.findmyfet.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Region {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "region_id")
    private Long id;

    @Column(unique = true, nullable = false)
    private String name; // 예: "서울시", "부산시"
}
```

**`Category.java`**```java
package com.busanit501.findmyfet.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "category_id")
    private Long id;

    @Column(unique = true, nullable = false)
    private String name; // 예: "개", "고양이"
}
```

**`Breed.java`**
```java
package com.busanit501.findmyfet.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Breed {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "breed_id")
    private Long id;

    @Column(nullable = false)
    private String name; // 예: "말티즈", "푸들"

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category; // 어떤 상위 카테고리에 속하는지 (예: 말티즈 -> 개)
}```

### Step 2: `Post` 엔티티 수정

기존의 `String` 필드들을 위에서 생성한 엔티티와의 `@ManyToOne` 연관 관계로 변경합니다.

```java
// Post.java

// ... 기존 필드 ...

// private String animalCategory; // -> 아래 코드로 변경
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "category_id")
private Category category;

// private String animalBreed; // -> 아래 코드로 변경
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "breed_id")
private Breed breed;

// private String location; // -> 아래 코드로 변경
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "region_id")
private Region region;

// ...
```

> **참고**: `latitude`, `longitude`는 게시글마다 고유한 값이므로 `Post` 엔티티에 그대로 둡니다.

### Step 3: 새로운 Repository 생성

새로운 엔티티들을 데이터베이스에서 조회하기 위한 Repository 인터페이스를 `repository` 패키지에 생성합니다.

**`RegionRepository.java`**
```java
public interface RegionRepository extends JpaRepository<Region, Long> {
    // 이름으로 Region을 찾기 위한 메서드 (서비스 로직에서 사용)
    Optional<Region> findByName(String name);
}
```

**`CategoryRepository.java`**
```java
public interface CategoryRepository extends JpaRepository<Category, Long> {
    Optional<Category> findByName(String name);
}
```

**`BreedRepository.java`**
```java
public interface BreedRepository extends JpaRepository<Breed, Long> {
    Optional<Breed> findByName(String name);
}
```

### Step 4: 초기 데이터 생성 (`data.sql`)

개발 및 테스트를 위해 `src/main/resources` 폴더에 `data.sql` 파일을 생성하여 마스터 테이블의 초기 데이터를 넣어줍니다. (Spring Boot가 실행될 때 이 스크립트를 자동으로 실행합니다)

```sql
-- src/main/resources/data.sql

-- Region 데이터
INSERT INTO region (name) VALUES ('서울시'), ('부산시'), ('대구시'), ('인천시'), ('광주시'), ('대전시'), ('울산시'), ('경기도'), ('강원도');

-- Category 데이터
INSERT INTO category (name) VALUES ('개'), ('고양이');

-- Breed 데이터 (category_id는 위에서 생성된 ID를 참조)
-- '개'의 category_id가 1이라고 가정
INSERT INTO breed (name, category_id) VALUES ('말티즈', 1), ('푸들', 1), ('골든리트리버', 1), ('진돗개', 1);
-- '고양이'의 category_id가 2라고 가정
INSERT INTO breed (name, category_id) VALUES ('코리안숏헤어', 2), ('페르시안', 2), ('러시안블루', 2), ('샴', 2);

-- 테스트용 User 데이터 (기존에 없다면 추가)
INSERT INTO user (loginid, password, name, phone_number, email, address, role, reg_date, mod_date) VALUES ('user123', '{bcrypt_password_hash}', '홍길동', '010-1234-5678', 'user@example.com', '서울시 강남구', 'User', NOW(), NOW());
```
> **주의**: `application.properties`에 `spring.jpa.hibernate.ddl-auto`가 `create` 또는 `create-drop`으로 설정되어 있어야 `data.sql`이 정상적으로 동작합니다.

### Step 5: `SearchService` 리팩토링

하드코딩된 목록 대신 DB에서 조회하도록 `SearchServiceImpl`을 수정합니다.

```java
// SearchServiceImpl.java

@Service
@RequiredArgsConstructor
public class SearchServiceImpl implements SearchService {

    private final CategoryRepository categoryRepository;
    private final BreedRepository breedRepository; // BreedRepository도 필요할 수 있음
    private final RegionRepository regionRepository;

    @Override
    public List<CategoryDto> getCategoryList() {
        // DB에서 모든 Category를 조회하여 CategoryDto 리스트로 변환
        // 실제로는 Category에 속한 Breed 목록도 함께 조회해야 함 (N+1 문제 주의)
        List<Category> categories = categoryRepository.findAll();
        // ... CategoryDto로 변환하는 로직 구현 ...
        return categories.stream().map(category -> {
            List<String> breedNames = breedRepository.findByCategory(category).stream()
                                                    .map(Breed::getName)
                                                    .collect(Collectors.toList());
            return new CategoryDto(category.getName(), breedNames);
        }).collect(Collectors.toList());
    }

    @Override
    public List<String> getRegionList() {
        // DB에서 모든 Region을 조회하여 이름(String) 리스트로 변환
        return regionRepository.findAll().stream()
                .map(Region::getName)
                .collect(Collectors.toList());
    }
}
```

### Step 6: `PostService` (작성/수정) 리팩토링

게시글을 생성하거나 수정할 때, `String`으로 받은 지역/카테고리 이름을 실제 엔티티 객체로 변환하여 `Post`에 설정해주는 로직이 필요합니다.

```java
// PostServiceImpl.java (createPost 메서드 예시)

// ... Repository 주입 필요
private final RegionRepository regionRepository;
private final CategoryRepository categoryRepository;
private final BreedRepository breedRepository;

@Override
@Transactional
public Long createPost(PostCreateRequestDto requestDto, List<MultipartFile> images, Long userId) {
    User user = // ... 사용자 조회 ...

    // DTO의 이름(String)으로 실제 마스터 엔티티를 DB에서 조회
    Region region = regionRepository.findByName(requestDto.getLocation())
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 지역입니다."));
    Category category = categoryRepository.findByName(requestDto.getAnimalCategory())
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 카테고리입니다."));
    Breed breed = breedRepository.findByName(requestDto.getAnimalBreed())
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 품종입니다."));
            
    // Post 엔티티 생성 (ModelMapper 또는 Builder 사용)
    Post post = Post.builder()
            .title(requestDto.getTitle())
            // ... 다른 필드들 ...
            .region(region)       // String 대신 조회한 Region 엔티티 설정
            .category(category)   // String 대신 조회한 Category 엔티티 설정
            .breed(breed)         // String 대신 조회한 Breed 엔티티 설정
            .user(user)
            .status(Status.ACTIVE)
            .build();
            
    Post savedPost = postRepository.save(post);
    // ... 이미지 처리 ...
    return savedPost.getId();
}
```
> **참고**: `PostCreateRequestDto`의 필드 타입은 그대로 `String`으로 두는 것이 일반적입니다. 서비스 계층에서 이 `String` 값을 이용해 엔티티를 조회하는 책임을 집니다.

### Step 7: 조회용 DTO 수정

상세 조회나 목록 조회 시, `Post` 엔티티에 연결된 마스터 엔티티의 `name` 필드를 가져오도록 DTO를 수정해야 합니다.

```java
// PostDetailResponseDto 생성자 예시
public PostDetailResponseDto(Post entity) {
    // ...
    // entity.getAnimalCategory() -> entity.getCategory().getName()
    this.animalCategory = entity.getCategory() != null ? entity.getCategory().getName() : null;
    this.animalBreed = entity.getBreed() != null ? entity.getBreed().getName() : null;
    this.location = entity.getRegion() != null ? entity.getRegion().getName() : null;
    // ...
}
```

---

이 가이드를 따라 차근차근 진행하시면, 더욱 견고하고 확장 가능한 구조로 프로젝트를 개선할 수 있습니다.
````