# 코드 개선 제안

## 1. 인증 사용자 정보 조회 방식의 일관성 확보

### 현황
현재 각 컨트롤러에서 로그인한 사용자 정보를 조회하는 방식이 다르게 구현되어 있습니다.

- **`UserController.java`**:
  ```java
  @GetMapping("/users/me")
  public ResponseEntity<CommonResponse<UserInfoResponseDTO>> getMe(@AuthenticationPrincipal Long userId) { ... }
  ```
  - `@AuthenticationPrincipal` 어노테이션을 사용하여 사용자의 고유 ID (`Long` 타입)를 직접 주입받습니다.

- **`CommentController.java`**:
  ```java
  @PostMapping(value = "/posts/{postId}/comments", ... )
  public ResponseEntity<CommentDTO> createComment(..., Principal principal) {
      String mid = principal.getName();
      ...
  }
  ```
  - `java.security.Principal` 객체를 주입받은 후, `.getName()` 메소드를 호출하여 사용자의 로그인 ID (`String` 타입)를 가져옵니다.

### 문제점
두 방식 모두 기능적으로는 올바르게 동작하지만, 다음과 같은 잠재적인 유지보수 문제를 가질 수 있습니다.

- **가독성 저하**: 코드를 처음 접하는 개발자가 어떤 방식을 따라야 할지 혼란을 겪을 수 있습니다.
- **유지보수 어려움**: 향후 인증 로직 변경 시, 여러 군데에 흩어져 있는 각기 다른 방식을 모두 수정해야 할 수 있습니다.
- **잠재적 오류 발생**: 두 방식이 혼용되면서 예기치 않은 타입 변환 문제나 `null` 관련 오류가 발생할 가능성이 있습니다.

### 개선 방안
프로젝트 전체적으로 **`@AuthenticationPrincipal`을 사용하는 방식으로 표준화**하는 것을 권장합니다.

- **이점**:
    - **일관성**: 코드 전체의 통일성을 유지하여 이해하기 쉽습니다.
    - **타입 안전성**: 컨트롤러 메소드에서 바로 원하는 타입(예: `Long userId`)으로 데이터를 받을 수 있어 안전합니다.
    - **간결성**: `Principal` 객체에서 `String`을 꺼내는 추가 과정 없이 코드가 더 간결해집니다.

### 예상되는 수정 (예시)
`CommentController`를 아래와 같이 수정할 수 있습니다.
(※ `JwtAuthenticationFilter` 또는 `UserDetailsService`에서 `Authentication` 객체의 `Principal`을 `User`의 ID(`Long` 타입)로 설정하도록 구성이 필요할 수 있습니다.)

```java
// 변경 전
public ResponseEntity<CommentDTO> createComment(..., Principal principal) {
    String mid = principal.getName();
    ...
    commentService.createComment(commentDTO, mid, imageFile);
}

// 변경 후
public ResponseEntity<CommentDTO> createComment(..., @AuthenticationPrincipal Long userId) {
    ...
    // CommentService는 userId를 받도록 수정하거나,
    // 기존처럼 loginId를 사용한다면 Service 내부에서 userId로 User를 조회해야 함
    commentService.createComment(commentDTO, userId, imageFile);
}
```
